new log(`rho:rchain:deployId`),
RevIssuerKit,
insertArbitrary(`rho:registry:insertArbitrary`),
lookup(`rho:registry:lookup`), vCh,
REVAddress(`rho:rev:address`)
in {
  lookup!(`rho:rchain:revVault`, *vCh) | for (@(_, *RevVault) <- vCh) {
    // Testing
    new kitCh, pCh,
    fromCh, toCh, pubKeyCh,
    vaultCh, targetVaultCh, revVaultkeyCh,
    DeployerIdOps(`rho:rchain:deployerId:ops`),
    deployerId(`rho:rchain:deployerId`)
    in {
      RevIssuerKit!(*kitCh) | for (@{"issuer": *issuer, ..._} <- kitCh) {
        log!(["got issuer"]) |
        issuer!("makeEmptyPurse", *pCh) | for (purse <- pCh) {
          log!(["got purse"]) |
          DeployerIdOps!("pubKeyBytes", *deployerId, *pubKeyCh) |
          for (@deployerPubKey <- pubKeyCh) {
            log!(["got deployer public key", deployerPubKey]) |
            purse!("getAddress", *toCh) |
            REVAddress!("fromPublicKey", deployerPubKey, *fromCh) |
            for (@from <- fromCh; @to <- toCh) {
              log!(["got from", from, "to", to]) |
              RevVault!("findOrCreate", from, *vaultCh) |
              // make sure the target vault it created and the transfer would be done
              RevVault!("findOrCreate", to, *targetVaultCh) |
              RevVault!("deployerAuthKey", *deployerId, *revVaultkeyCh) |
              for (@(true, vault) <- vaultCh ; key <- revVaultkeyCh ; @(true, _) <- targetVaultCh) {
                log!(["Beginning transfer of ", 100, "REVlette from", from, "to", to]) |

                new resultCh in {
                  @vault!("transfer", to, 100 /*amount*/, *key, *resultCh) |
                  for (@result <- resultCh) {
                    log!(("Finished transfer of ", 100, "REV to", to, "result was:", result)) |
                    new kCh, iCh in {
                      insertArbitrary!(*RevIssuerKit, *kCh) |
                      insertArbitrary!(*issuer, *iCh) |
                      for (@kUri <- kCh; @iUri <- iCh) {
                        log!(["tests passed; inserted RevIssuerKit at", kUri, "REV issuer at", iUri])
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } |

    contract RevIssuerKit(ret) = {
      new issuer, makePurseKit /* TODO: amountMath, brand */ in {

        // The corresponding mint is the REV mint; clearly we don't have that to give out.
        ret!({"mint": Nil, "issuer": bundle+{*issuer}}) |

        contract issuer(@"makeEmptyPurse", ret) = {
          new kitCh in {
            makePurseKit!(*kitCh) | for (@{"purse": *purse, ..._} <- kitCh) {
              ret!(bundle+{*purse}) // already bundled, but... it's a good habit.
            }
          }
        }
        |
        contract makePurseKit(kitRet) = {
          new purse, un, addrCh, balCh, vaultCh in {
            balCh!(0) |
            REVAddress!("fromUnforgeable", *un, *addrCh) | for (@purseAddr <- addrCh) {
              RevVault!("findOrCreate", purseAddr, *vaultCh) | for (vault <- vaultCh) {
                kitRet!({"purse": bundle+{*purse}, "address": purseAddr}) |

                contract purse(@"getAddress", ret) = { ret!(purseAddr) } |
                contract purse(@"getBalance", ret) = { for (@balance <<- balCh) { ret!(balance) } } |
                contract purse(@"getKey", @sealedDispatch, ret) = {
                  if (sealedDispatch == {bundle0{(*makePurseKit, *ret)}}) {
                    new keyCh in {
                      RevVault!("unforgeableAuthKey", *un, *keyCh) |
                      for (@balance <<- balCh) {
                        for (@key <- keyCh) {
                          ret!((true, {"key": key, "seal": bundle0{(*makePurseKit, key)},
                          "vault": *vault, "address": purseAddr, "balance": balance }))
                        }
                      }
                    }
                  } else {
                    ret!((false, "bad sealedDispatch"))
                  }
                } |

                contract purse(@"deposit", allegedPayment, ret) = {
                  new keyCh, amtCh, pAddrCh, pvCh, txCh in {
                    allegedPayment!("getKey", bundle0{(*makePurseKit, *keyCh)}, *keyCh) |
                    for (@(true, {"key": pmtAuthKey, "seal": seal,
                    "vault": *pmtVault, "address": pmtAddr, "balance": amount }) <- keyCh) {
                      if (seal == {bundle0{(*makePurseKit, pmtAuthKey)}}) {
                        pmtVault!("transfer", purseAddr, amount, pmtAuthKey, *txCh) |
                        for (@(ok, x) <- txCh; @balance <- balCh) {
                          ret!((ok, x)) |
                          match ok {
                            true => balCh!(balance + amount)
                            false => balCh!(balance)
                          }
                        }
                      } else {
                        ret!((false, "bad seal"))
                      }
                    }
                  }
                }
                |
                contract purse(@"withdraw", @amount, ret) = {
                  new pCh, keyCh, txCh in {
                    makePurseKit!(*pCh) |
                    for (@{"purse": *withdrawal, "address": wAddr, ..._} <- pCh) {
                      RevVault!("unforgeableAuthKey", *un, *keyCh) | for (authKey <- keyCh) {
                        vault!("transfer", wAddr, amount, *authKey, *txCh) |
                        for (@(ok, x) <- txCh; @balance <- balCh) {
                          match ok {
                            true => {
                              balCh!(balance - amount) |
                              ret!((true, *withdrawal))
                            }
                            false => {
                              ret!((ok, x)) |
                              balCh!(balance)
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
