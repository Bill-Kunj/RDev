match ["inbox", "", ""] {
  [lockerTag, group, issue] => {
    new
    //                 type and subtype are optional
    
    deployId(`rho:rchain:deployId`),
    deployerId(`rho:rchain:deployerId`),
    ch
    in {
      for(@{"peek": *peek, "URI": uri ..._} <<- @[*deployerId, lockerTag]) {
        deployId!({"URI": uri}) |
        peek!(type,subtype,*deployId)
        new lockerCh, ret, ret1, ret2, ret3, loop, $stdout, $lookup in {     lookup!($locker_%%$myusername, *lockerCh) |
        peek!("member", group, *ret) |
        peek!("issue", issue, *ret1) |
        for ( @[{"read": *read, ..._}, ..._] <- ret;  @[{"admin": *admin, ..._}, ..._] <- ret1 ) {
          stdout!("adding users") |
          contract loop ( @map ) = {
            match  map {
              {} => Nil
              {  username: {"inbox": *inbox, "delegate": delegate, ..._}, ...tail } => {
                stdout!(["user",username]) |
                admin!("giveRightToVote", username, *ret2) |
                for (@vote <- ret2) {
                  stdout!([username, "added"]) |
                  inbox!(["vote", $ballot, vote], *stdout) |
                  @vote!("delegate",delegate, *stdout)
                }|
                loop!(tail)
              }
               somethingelse => stdout!(["somethingelse", somethingelse])
            }
          }|
          read!(*ret3) |
          for ( @members <- ret3 ) {
            stdout!(["keys",members.keys()]) |
            loop!(members)
          }
        }
      }
   }
}
  
}} // end of match
