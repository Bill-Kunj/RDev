new Inbox,
insertArbitrary(`rho:registry:insertArbitrary`),
lookup(`rho:registry:lookup`),
log(`rho:io:stderr`)
in {
  log!("@@hi from Inbox test")|
  new announceCh, wallClock in {

    new secretaryDeployer in {
      match [*secretaryDeployer, "mailbox"] {
        locker => {
          Inbox!(locker) |
          for (@{"inbox": *inbox, "address": address, ..._} <<- @locker) {
            // log!({"sec address": secBox.get("address")}) |
            announceCh!!(address) |
            for (_ <- wallClock) {
              new ch in {
                inbox!("peek", 0, *ch) |
                for (@method, @args <- ch) {
                  log!({"@@sec inbox received": method, "args": args}) |
                  match method {
                    "register" => {
                      inbox!("extract", 0, Nil) |
                      new ticket in {
                        lookup!(args.get("replyTo"), *ch) |
                        for (memBox <- ch) {
                          log!({"@@grant at": args.get("replyTo"), "ticket": *ticket}) |
                          memBox!("grant", {"ticket": *ticket}, Nil)
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    |
    new member1Deployer in {
      match [*member1Deployer, "mailbox"] {
        mem1Box => {
          Inbox!(mem1Box) |
          for (@{"inbox": inbox, "address": address, ..._} <<- @mem1Box) {
            for (@secAddr <<- announceCh) {
              log!({"mem1 got secAddr": secAddr}) |
              new ch in {
                lookup!(secAddr, *ch) |
                for (secBox <- ch) {
                  log!({"mem1 got secBox": *secBox}) |
                  secBox!("register", {
                    "title": "Meeting 123",
                    "nickName": "mem1",
                    "replyTo": address
                    }, *ch) |
                  for (_ <- ch) {
                    log!({"@@sent": "request to register", "title": "Meeting 123", "from": address}) |
                    wallClock!(Nil)
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  |
  contract Inbox(return) = {
    // log!({"Inbox return": *return}) |
    new inbox, shared, msgsCh, addrCh in {
      msgsCh!([]) |

      insertArbitrary!(*shared, *addrCh) |
      for (@address <- addrCh) {
        log!({"inbox address": address, " external facet": *shared}) |
        return!({"inbox": *inbox, "shared": *shared, "address": address})
      }

      |
      contract shared(@method /\ String, @args /\ Map, return) = {
        // log!({"shared (deliver)": method, "args": args}) |
        for (@msgs <- msgsCh) {
          msgsCh!(msgs ++ [(method, args)]) |
          return!(Nil)
        }
      }
      |
      contract inbox(@"getExternalFacet", return) = {
        // log!({"getExternalFacet": *return}) |
        return!(*shared)
      }
      |
      contract inbox(@"peek", @ix /\ Int, return) = {
        // log!({"peek at": ix}) |
        for (@msgs <<- msgsCh) {
          // log!({"peek msgs length": msgs.length()}) |
          match msgs.nth(ix) {
            (method, args) => return!(method, args)
            _ => return!(Nil, Nil)
          }
        }
      }
      |
      contract inbox(@"extract", @ix /\ Int, return) = {
        for (@msgs <- msgsCh) {
          // log!({"extract msgs length": msgs.length()}) |
          if (ix < msgs.length()) {
            msgsCh!(msgs.slice(0, ix) ++ msgs.slice(ix + 1, msgs.length())) |
            match msgs.nth(ix) {
              (method, args) => return!(method, args)
            }
          } else {
            msgsCh!(msgs) |
            return!(Nil)
          }
        }
      }
    }
  }
}
