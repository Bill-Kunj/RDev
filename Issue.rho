// @title Voting with liquid delegation.
// originally from https://github.com/rchain-community/rchain-api/blob/master/examples/voting-locker/chairRole.rho
new Issue,
trace(`rho:io:stderr`),
log(`rho:io:stderr`)
in {
  new insertArbitrary(`rho:registry:insertArbitrary`), uriCh in {
    insertArbitrary!(bundle+{*Issue}, *uriCh) | for(@uri <- uriCh) {
      stdout!(["#define $Issue", uri])
    }
  }
  |

  // See example / demo below.
  //contract Issue(@{proposalNames /\ Set(hd, ...tail)}, return) = {
  contract Issue(@proposalNames , return) = {
    new admin, tally, voterCh in {
      stdout!("creating ballot") |
      return!(bundle+{*admin}, bundle+{*tally}) |
       voterCh!({}) |

      // Instruct the secretary to issueBallot for each voter.
      secretary!("issueBallot", *v1Ch) | // "Owans"
      secretary!("issueBallot", *v2Ch) | // "jimscarver"
      secretary!("issueBallot", *v3Ch) | // "aviation_hacker"
      secretary!("issueBallot", *v4Ch) | // "momchilov"

      for(v1 <- v1Ch; v2 <- v2Ch; v3 <- v3Ch; v4 <- v4Ch) {
        // TODO: layer delegation on top.
        // v3!("delegate", "jimscarver", *v3Ch) |
        // v2!("delegate", "Owens", *v3Ch) |
        // v2!("delegate", "Owans", *v3Ch) |
        // for(_1 <- v3Ch; _2 <- v3Ch ) {
        log!("voting.") |

        // Cast a ballot by giving a map of question to answer.
        v1!("vote", {"President": "Lincoln"}, *ack) |
        for (@(true, _) <- ack) {
          // A voter may revise their answers to one or more questions.
          v1!("vote", {"President": "Douglas"}, *v1Ch) |

          // Only questions and answers on the ballot are accepted.
          v1!("vote", {"President": "Abe Lincoln"}, *log) |

          v2!("vote", {"President": "Lincoln"}, *v2Ch) |
          v3!("vote", {"President": "Lincoln"}, *v3Ch) |
          v4!("vote", {"President": "Lincoln"}, *v4Ch) |
          for(@(true, _) <- v1Ch; @(true, _) <- v2Ch; @(true, _) <- v3Ch; @(true, _) <- v4Ch) {
            trace!("votes done") |

            // Get a read-only facet of the secretary.
            secretary!("getCounterFacet", *ack) |
            for (counter <- ack) {

              // Count the votes cast.
              counter!("countVotesCast", *ack) |
              for (@votes <- ack) {
                log!({"votes": votes}) |

                // Use the read-only facet to get the title, questions.
                counter!("title", *log) |
                counter!("questions", *log)
              }
            }
          }
        }
      }
    }
  }
  |
  contract Secretary(@title, @questions, return) = {
    new secretary, counter, voterStatesCh in {
      log!({"meeting title": title, "# questions": questions.size(), "->secretary": *secretary}) |
      voterStatesCh!([]) |
      return!(bundle+{*secretary}) |

      contract secretary(@"getCounterFacet", return) = {
        // log!("getCounterFacet") |
        return!(bundle+{*counter})
      }
      |
      contract counter(@"questions", return) = { return!(questions) }
      |
      contract counter(@"title", return) = { return!(title) }
      |
      contract counter(@"countVotesCast", return) = {
        log!("countVotesCast") |
        for (@voterStates <<- voterStatesCh) {
          new reduceVoters in {
            reduceVoters!(voterStates, {}) |
            // ISSUE: reuse filter / reduce from some standard library?
            contract reduceVoters(@current, @acc) = {
              // log!({"reduceVoters current": current, "acc": acc}) |
              match current {
                [*v0Ch, ...v1n] => {
                  for (@choices <<- v0Ch) {
                    // log!({"tallying": choices}) |
                    new reduceChoices in {
                      reduceChoices!(choices, acc) |
                      contract reduceChoices(@current, @acc) = {
                        // log!({"reduceChoices current": current, "acc": acc}) |
                        match current {
                          // bogus questions / answers are filtered out in vote below
                          {q0: a0, ...qa1n} => {
                            match acc.getOrElse(q0, {}) {
                              answerCounts => {
                                match answerCounts.getOrElse(a0, 0) + 1 {
                                  newCount => {
                                    reduceChoices!(qa1n, acc.set(q0, answerCounts.set(a0, newCount)))
                                  }
                                }
                              }
                            }
                          }
                          {} => { reduceVoters!(v1n, acc) }
                        }
                      }
                    }
                  }
                }
                [] => { return!(acc) }
              }
            }
          }
        }
      }
      |
      contract secretary(@"issueBallot", return) = {
        new voterCh in {
          Voter!(questions, *voterCh) |
          for (voter, choicesCh <- voterCh) {
            for (@voterChoices <- voterStatesCh) {
              voterStatesCh!(voterChoices ++ [*choicesCh]) |
              log!({"nth": voterChoices.length(), "->voter": *voter}) |
              return!(*voter)
            }
          }
        }
      }
    }
  }
  |
  new bCh, v1Ch, v2Ch, v3Ch, v4Ch in {
    trace!("creating Issue") |
    Issue!(Set("Lincoln", "Douglas"), *bCh) |
    for (admin, tally <- bCh) {
      trace!({"Issue returned": *admin}) |
      admin!("giveRightToVote", "Owans", *v1Ch) |
      admin!("giveRightToVote", "jimscarver", *v2Ch) |
      admin!("giveRightToVote", "aviation_hacker", *v3Ch) |
      admin!("giveRightToVote", "momchilov", *v4Ch) |
      for(v1 <- v1Ch; v2 <- v2Ch; v3 <- v3Ch; v4 <- v4Ch) {
        v3!("delegate", "jimscarver", *v3Ch) |
        v2!("delegate", "Owens", *v3Ch) |
        v2!("delegate", "Owans", *v3Ch) |
        for(_ <- v3Ch; _ <- v3Ch ) {
          trace!("voting.") |
          v1!("vote", "Lincoln", *trace, *v1Ch) |
          v1!("vote", "Douglas", *trace, *v1Ch) |
          v1!("vote", "Abe Lincoln", *trace, *v1Ch) |
          v4!("vote", "Lincoln", *trace, *v2Ch) |
          for(_ <- v1Ch; _ <- v1Ch; _ <- v1Ch; _ <- v2Ch) {
            trace!("votes done") |
            tally!(*bCh) |
            for(@w <- bCh) {
              trace!({"tally": w})
            }
          }
        }
      }
    }
  }
}
