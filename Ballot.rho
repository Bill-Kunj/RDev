/**
 * @title Ballot - a one-member-one-vote contract
 *
 * "A member may cast his or her vote solely by means of written
 * or electronic ballot. Whether or not the member is present in
 * person at the meeting or by proxy, his or her vote will be counted
 * only if (a) it is submitted on the form of ballot furnished by
 * the Secretary for use in connection with the meeting, and
 * (b) the executed ballot is received by the Secretary no later than
 * whatever deadline for ballot submissions the
 * Nominating and Governance Committee may designate for the purpose
 * of allowing the Secretary sufficient time to count the votes cast,
 * which deadline may not be more than seven days prior to the
 * commencement of the meeting"
 * -- Artile II section 6 Amended Bylaws October 8, 2018
 * https://github.com/rchain/board/blob/master/Bylaws.md#user-content-voting
 *
 * Note: the questions and answers are fixed before any ballots are issued.
 *
 * TODO: cancelBallot method in case a member loses control
 *       of their ballot and requests a re-issue.
 * ISSUE: put voter states in a map to give them names (e.g. to support cancel)?
 * ISSUE: keep voter metadata?
 */
new Secretary, Voter,
trace(`rho:io:stderr`),
log(`rho:io:stderr`)
in {
  new insertArbitrary(`rho:registry:insertArbitrary`), uriCh in {
    insertArbitrary!(bundle+{*Secretary}, *uriCh) | for(@uri <- uriCh) {
      log!({"Secretary": uri})
    }
  }
  |

  // Demo / example
  new ack, v1Ch, v2Ch, v3Ch, v4Ch in {
    // Construct a Secretary by giving a title and a map from
    // question to set of answers.
    Secretary!("Lincoln v Douglas", {"President": Set("Lincoln", "Douglas")}, *ack) |
    for (secretary <- ack) {
      log!({"Secretary returned": *secretary}) |

      // Instruct the secretary to issueBallot for each voter.
      secretary!("issueBallot", *v1Ch) | // "Owans"
      secretary!("issueBallot", *v2Ch) | // "jimscarver"
      secretary!("issueBallot", *v3Ch) | // "aviation_hacker"
      secretary!("issueBallot", *v4Ch) | // "momchilov"

      for(v1 <- v1Ch; v2 <- v2Ch; v3 <- v3Ch; v4 <- v4Ch) {
        // TODO: layer delegation on top.
        // v3!("delegate", "jimscarver", *v3Ch) |
        // v2!("delegate", "Owens", *v3Ch) |
        // v2!("delegate", "Owans", *v3Ch) |
        // for(_1 <- v3Ch; _2 <- v3Ch ) {
        log!("voting.") |

        // Cast a ballot by giving a map of question to answer.
        v1!("vote", {"President": "Lincoln"}, *ack) |
        for (@(true, _) <- ack) {
          // A voter may revise their answers to one or more questions.
          v1!("vote", {"President": "Douglas"}, *v1Ch) |

          // Only questions and answers on the ballot are accepted.
          v1!("vote", {"President": "Abe Lincoln"}, *log) |

          v2!("vote", {"President": "Lincoln"}, *v2Ch) |
          v3!("vote", {"President": "Lincoln"}, *v3Ch) |
          v4!("vote", {"President": "Lincoln"}, *v4Ch) |
          for(@(true, _) <- v1Ch; @(true, _) <- v2Ch; @(true, _) <- v3Ch; @(true, _) <- v4Ch) {
            trace!("votes done") |

            // Get a read-only facet of the secretary.
            secretary!("getCounterFacet", *ack) |
            for (counter <- ack) {

              // Count the votes cast.
              counter!("countVotesCast", *ack) |
              for (@votes <- ack) {
                log!({"votes": votes}) |

                // Use the read-only facet to get the title, questions.
                counter!("title", *log) |
                counter!("questions", *log)
              }
            }
          }
        }
      }
    }
  }
  |
  contract Secretary(@title, @questions, return) = {
    new secretary, counter, voterStatesCh in {
      log!({"meeting title": title, "# questions": questions.size(), "->secretary": *secretary}) |
      voterStatesCh!([]) |
      return!(bundle+{*secretary}) |

      contract secretary(@"getCounterFacet", return) = {
        // log!("getCounterFacet") |
        return!(bundle+{*counter})
      }
      |
      contract counter(@"questions", return) = { return!(questions) }
      |
      contract counter(@"title", return) = { return!(title) }
      |
      contract counter(@"countVotesCast", return) = {
        log!("countVotesCast") |
        for (@voterStates <<- voterStatesCh) {
          new reduceVoters in {
            reduceVoters!(voterStates, {}) |
            // ISSUE: reuse filter / reduce from some standard library?
            contract reduceVoters(@current, @acc) = {
              // log!({"reduceVoters current": current, "acc": acc}) |
              match current {
                [*v0Ch, ...v1n] => {
                  for (@choices <<- v0Ch) {
                    // log!({"tallying": choices}) |
                    new reduceChoices in {
                      reduceChoices!(choices, acc) |
                      contract reduceChoices(@current, @acc) = {
                        // log!({"reduceChoices current": current, "acc": acc}) |
                        match current {
                          // bogus questions / answers are filtered out in vote below
                          {q0: a0, ...qa1n} => {
                            match acc.getOrElse(q0, {}) {
                              answerCounts => {
                                match answerCounts.getOrElse(a0, 0) + 1 {
                                  newCount => {
                                    reduceChoices!(qa1n, acc.set(q0, answerCounts.set(a0, newCount)))
                                  }
                                }
                              }
                            }
                          }
                          {} => { reduceVoters!(v1n, acc) }
                        }
                      }
                    }
                  }
                }
                [] => { return!(acc) }
              }
            }
          }
        }
      }
      |
      contract secretary(@"issueBallot", return) = {
        new voterCh in {
          Voter!(questions, *voterCh) |
          for (voter, choicesCh <- voterCh) {
            for (@voterChoices <- voterStatesCh) {
              voterStatesCh!(voterChoices ++ [*choicesCh]) |
              log!({"nth": voterChoices.length(), "->voter": *voter}) |
              return!(*voter)
            }
          }
        }
      }
    }
  }
  |
  contract Voter(@questions, return) = {
    new voter, choicesCh in {
      // return a channel for casting votes and for reading the results
      // ISSUE: we trust the caller to peek at the choices and not consume them.
      return!(bundle+{*voter}, bundle-{*choicesCh}) |
      choicesCh!({}) |
      contract voter(@"vote", @newChoices /\ Map, return) = {
        // log!({"voter": *voter, "newChoices": newChoices}) |
        for (@previous <- choicesCh) {
          // log!({"voter": *voter, "newChoices": newChoices, "previous": previous}) |
          new checkChoices in {
            checkChoices!(newChoices, previous)
            |
            // ISSUE: reuse reduce from some standard library?
            contract checkChoices(@toCheck, @checked) = {
              match toCheck {
                {} => {
                  log!({"voter": *voter, "choices": checked, "replaced": previous}) |
                  choicesCh!(checked) |
                  return!((true, checked))
                }
                { q: a, ...rest} => {
                  match questions.get(q) {
                    Nil => {
                      choicesCh!(previous) |
                      log!({"voter": *voter, "no such question": q}) |
                      return!((false, "no such question", q))
                    }
                    answers => {
                      match answers.contains(a) {
                        false => {
                          choicesCh!(previous) |
                          log!({"voter": *voter, "question": q, "no such answer": a, "checked": checked}) |
                          return!((false, "no such answer", q, a))
                        }
                        true => {
                          checkChoices!(rest, checked.set(q, a))
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
