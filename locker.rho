// originally from https://github.com/rchain-community/rchain-api/blob/master/examples/voting-locker/locker.rho
new
  Locker,
  verifySignatureCh,
  trace(`rho:io:stderr`),
  stdout(`rho:io:stdout`),
  insertArbitrary(`rho:registry:insertArbitrary`),
  secpVerify(`rho:crypto:secp256k1Verify`),
  blake2b256(`rho:crypto:blake2b256Hash`)
  // lookup(`rho:registry:lookup`)
in {

  // Test / demo
   new lockerCh, ackCh, rx in {
    Locker!(
      "pubkey",
      "abcdef",
      *lockerCh
    ) |

    for (locker <- lockerCh) {

      new uriCh in {
        insertArbitrary!(*locker, *uriCh) |
        for(@uri <- uriCh) {
          stdout!(["locker created at",uri])
        }
      }
    }
  } | 

  new uriCh in {
    insertArbitrary!(*Locker, *uriCh) | for(@uri <- uriCh) {
      stdout!(["#define $Locker",uri])
    }
  } |

  contract Locker(@{pubKey /\ String}, @{initialNonce /\ String}, return) = {
    new self, itemsCh, nonceCh, publicKeyCh, hashCh in {

      trace!("making locker") |
      return!(*self) |
      itemsCh!({}) |
      nonceCh!(initialNonce) |

      // Get nonce
      contract self(@"getNonce", return) = {
        for(@nonce <<- nonceCh) { return!(nonce) }
      } |


      // Update the value of items in itemsCh
      // Need a valid signature and a new nonce
      contract self(@"update", @{signature /\ String}, @{nextNonce /\ String}, @{more /\ {..._}}) = {
        
        trace!({"locker.update": more}) |
        
        for(@nonce <<- nonceCh) {
          stdout!(nonce) |
          stdout!(pubKey) |

          blake2b256!(
            nonce.toUtf8Bytes(),
            *hashCh
          ) |

          for (@hash <- hashCh) {
            secpVerify!(
              hash,
              signature.hexToBytes(),
              pubKey.hexToBytes(),
              *verifySignatureCh
            ) |
            
            for (@result <- verifySignatureCh) {
              stdout!(result) |
              match result {
                true => {
                  trace!("signature verified") |
                  for (_ <- nonceCh; @items <- itemsCh) {
                    nonceCh!(nextNonce) |
                    itemsCh!(items.union(more)) |
                    trace!("update successful")
                  }
                }
                _ => {
                  trace!("wrong signature")
                }
              }
            }
          }
        }        
      } |


      // Get items in itemsCh
      // Need a valid signature and a new nonce
      // TODO
      contract self(@"get", @{sig /\ ByteArray}, @nextNonce, fail, return) = {
        trace!("locker.get(...)") |
        for(@nonce <- nonceCh) {
          if (nonce + 1 != nextNonce) {
            fail!({"expected nonce": nonce + 1}) |
            nonceCh!(nonce)
          } else {
            nonceCh!(nextNonce) |
            // TODO: real sig checking over nonce
            if ("dead".hexToBytes() ++ sig != pubKey) {
              fail!("bad signature")
            } else {
              for (@items <- itemsCh) {
                // trace!({"get items": items}) |
                itemsCh!(items) |
                return!(items)
              }
            }
          }
        }
      }
    }
  }
}
