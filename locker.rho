new return(`rho:rchain:deployId`), stdout(`rho:io:stdout`), 
mylocker(`rho:rchain:deployerId`), ack in {
stdout!("defining locker") |
  new lockerCh in {
   lockerCh!({}) |
   contract mylocker(@"read",return) = {
stdout!("doing a locker read") |
    for ( mystuff <<- lockerCh ) {
     return!(*mystuff)
   }} |
  contract mylocker(@"write",stuff,return) = {
stdout!("doing a locker write") |
    for ( mystuff <- lockerCh ) {
     lockerCh!(*stuff) |
     return!(*mystuff)
   }} | 
   contract mylocker(@"get",key,return) = {
stdout!("doing a locker get") |
    for ( mystuff <<- lockerCh ) {
     return!(*mystuff.get(*key))
   }} |
  contract mylocker(@"set",key,value,return) = {
stdout!("doing a locker set") |
    for ( mystuff <- lockerCh ) {
     if ( *value == Nil ) {
       lockerCh!(*mystuff.delete(*key))
     } else {
      lockerCh!(*mystuff.set(*key,*value))
     } |
     return!(*mystuff)
  }} |
  //Testing locker
 mylocker!("write",{"x": 5 },*ack) |
 for (_ <- ack ) {
  mylocker!("set","y", 1,*ack) |
stdout!("locker updated") |
 for (_ <- ack ) {
stdout!("reading locker") |
  mylocker!("read", *ack) |
   for (mystuff <- ack ) {
    stdout!(*mystuff) |
    return!(*mystuff) 
}}}}}
